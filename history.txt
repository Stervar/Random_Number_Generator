������������� �����: 40
������������� �����: 51
������������� �����: 62
������������� �����: 18
������������� �����: 18.17
������������� �����: 21.96
������������� �����: 23.08
������������� �����: 75.21
������������� �����: 25.79
������������� �����: 17.51
Предоставь мне код со всеми этими изминениями import secrets

def generate_crypto_secure_numbers(self):
    """
    Генерация криптографически стойких случайных чисел
    """
    min_val = self.min_input.value()
    max_val = self.max_input.value()
    count = self.count_input.value()
    
    secure_numbers = [secrets.randbelow(max_val - min_val + 1) + min_val 
                      for _ in range(count)]
    return secure_numbersimport string

def generate_password(self):
    """
    Генерация случайных паролей
    """
    length = self.count_input.value()
    use_uppercase = self.uppercase_check.isChecked()
    use_numbers = self.numbers_check.isChecked()
    use_symbols = self.symbols_check.isChecked()
    
    characters = string.ascii_lowercase
    if use_uppercase:
        characters += string.ascii_uppercase
    if use_numbers:
        characters += string.digits
    if use_symbols:
        characters += string.punctuation
    
    passwords = [''.join(random.choice(characters) for _ in range(length)) 
                 for _ in range(5)]  # Генерируем 5 паролей
    return passwords

def add_password_generator_ui(self):
    """
    Добавление UI для генератора паролей
    """
    self.uppercase_check = QCheckBox("Заглавные буквы")
    self.numbers_check = QCheckBox("Цифры")
    self.symbols_check = QCheckBox("Спецсимволы")
    
    self.password_button = QPushButton("Сгенерировать пароли")
    self.password_button.clicked.connect(self.generate_and_show_passwords)
    def __init__(self):
    # Добавляем новые элементы управления
    
    # Выбор распределения
    self.distribution_select = QComboBox()
    self.distribution_select.addItems([
        'Равномерное', 
        'Нормальное', 
        'Экспоненциальное', 
        'Пуассона'
    ])
    layout.addWidget(QLabel("Распределение:"), 5, 0)
    layout.addWidget(self.distribution_select, 5, 1)

def generate_advanced_numbers(self):
    """
    Генерация чисел с расширенными настройками
    """
    distribution = self.distribution_select.currentText()
    count = self.count_input.value()
    
    if distribution == 'Равномерное':
        numbers = [random.uniform(0, 1) for _ in range(count)]
    elif distribution == 'Нормальное':
        numbers = [random.gauss(0, 1) for _ in range(count)]
    elif distribution == 'Экспоненциальное':
        numbers = [random.expovariate(1) for _ in range(count)]
    elif distribution == 'Пуассона':
        numbers = [random.poisson(3) for _ in range(count)]
    
    return numbers
    from matplotlib.backends.backend_qt5agg import FigureCanvasQTAgg as FigureCanvas
import matplotlib.pyplot as plt

def visualize_numbers(self, numbers):
    """
    Создание графика распределения сгенерированных чисел
    """
    plt.figure(figsize=(10, 6))
    plt.hist(numbers, bins='auto', alpha=0.7, color='skyblue', edgecolor='black')
    plt.title('Распределение сгенерированных чисел')
    plt.xlabel('Значение')
    plt.ylabel('Частота')
    
    # Создаем холст matplotlib для PyQt
    canvas = FigureCanvas(plt.gcf())
    
    # Создаем диалоговое окно для отображения графика
    dialog = QDialog(self)
    dialog.setWindowTitle('Визуализация')
    layout = QVBoxLayout()
    layout.addWidget(canvas)
    dialog.setLayout(layout)
    dialog.exec_()
    def generate_unique_numbers(self):
    """
    Генерация уникальных случайных чисел
    """
    min_val = self.min_input.value()
    max_val = self.max_input.value()
    count = self.count_input.value()
    
    try:
        unique_numbers = random.sample(range(min_val, max_val + 1), count)
        return unique_numbers
    except ValueError:
        return "Невозможно сгенерировать уникальные числа с заданными параметрами"

def generate_weighted_random(self):
    """
    Генерация чисел с весовыми коэффициентами
    """
    numbers = [1, 2, 3, 4, 5]
    weights = [0.1, 0.2, 0.3, 0.2, 0.2]
    result = random.choices(numbers, weights=weights, k=self.count_input.value())
    return result